# Rigid Body Simulation
A rigid body simulation is somewhat like the particle simulation's covered previously, but on objects with actual shape and geometry as opposed to single points.
![](Pasted%20image%2020231020112636.png)
Like a particle, a rigid body has a position $(x, y, z)$, but it also has an *orientation* expressed in it's rotation along each of the 3 axis. We say that a particle has **3 degrees of freedom**, while a rigid body has **6 degrees of freedom**. These extra degrees of freedom make rigid body simulation significantly more complicated.

The main challenge is how the rigid body interacts with the environment compared to a particle.
When dropping a particle on a surface, the interaction is simple in that it can stop, reflect off, etc. In contrast, dropping a rigid body on a surface can have many very different outcomes that are dependent on many variables. For example, if we drop a rigid body on the edge of a surface, it is expected to tilt and come to rest at an angle:
![](Pasted%20image%2020231020113140.png)
Determining the amount of rotation requires calculating the torque of the object (i.e. the rotational force) in addition to the regular force.
Generally a technique called **impulse-based collisions** is used for rigid body simulations. With this technique, instead of calculating forces and allowing them to influence the acceleration of an object, thus changing its speed and trajectory, the simulation directly affects the velocity of the body. This is a technique that could also be used in mass spring models.

![](Pasted%20image%2020231020113748.png)
Consider the case where the object falls into the middle of the surface, and *should* settle to a stable position. It is a common mistake in some simulations that, because of miniscule differences in points along the bottom of the body, there will be an extremely slight difference in force exerted and the object will move when it should be static. This can cause objects to vibrate; we fix this by defining a "**rest in contact**" state where objects that satisfy some condition are declared as static and not simulated at all (until an external force releases it from this state).
This leads to a further problem called "stacking", which is the state achieved when multiple rigid bodies are at rest on each other, for example:
![](Pasted%20image%2020231020114305.png)
This can be a tricky state to handle because when one object is affected by some force and leaves the rest state, it is likely that the other objects it is touching should be affected too. 
## Articulated Rigid Body Simulation
Similar to joints in a rig, we want to simulate some rigid bodies that are bound together by some articulated joints. For example:
![](Pasted%20image%2020231020114516.png)
We can see that this object has **7 degrees of freedom**: this is because each of the separate rigid bodies has 6 DOF, but the joint constraint prevents them both from rotating in 2 directions (-2 DOF) and also prevents one of them from moving away from the other (-3 DOF). The 7 degrees of freedom are:
- Overall position $(x, y, z)$
- Overall rotation (in three directions)
- Angle of the joint between the two rigid bodies, in one direction.

These articulated rigid bodies can be used for simulating rigged meshes as ragdolls, but they are also useful for any kind of object with rigid connected components. For example, a car has a main rigid body with wheels attached with a single degree of freedom (rotating to go backwards or forwards).
# Deformable Object Simulation
The other kind of simulation we will discuss is deformable object simulation, where objects are not solid. For example, this elastic octopus:
![](Pasted%20image%2020231020122032.png)
This type of simulation often uses the Finite Element Method (FEM). First, we convert our mesh to tetrahedrons, which is what this method acts upon, by performing Tetrahedralization:
![](Pasted%20image%2020231020123007.png)
This is because tetrahedrons are the simplest possible 3D volumes (similarly to how triangles are the simplest possible 2D shapes for surfaces).
In this method, each tetrahedron has a **rest shape** and a **deformed shape**. We take the tetrahedrons generated by tetrahedralization as the rest shapes.
![](Pasted%20image%2020231020123158.png)
The tetrahedron tends towards this rest shape; FEM allows us to compute the forces that bring the deformed shape back to the rest shape. This is quite similar (at a high level) to the mass-spring model, but with a 3D volume instead of a 1D line.

Mass-spring models can also be used to animate deformable objects such as cloth:
![](Pasted%20image%2020231020123634.png)
And for "fracture simulations", but instead of having the springs behave elastically and stretch we have them withstand a certain amount of force before breaking completely:
![](Pasted%20image%2020231020123750.png)
# Fluid Simulation
(Note that in the context of fluid simulations, gases are fluids. These simulation techniques are for both liquids and gases.)
![](Pasted%20image%2020231020123825.png)
Fluid simulation is often particle-based. At simulation time, the liquid is represented as a large amount of separate particles, which are later connected together and converted into a mesh that appears like a contiguous fluid. TA common technique for solving this method is **Lagrangian Fluid Simulation**.
![](Pasted%20image%2020231020124002.png)
Another kind of fluid simulation is "grid-based fluid simulation". We define a bounding box for the fluid simulation, and then divide it into a regular grid of voxels:
![](Pasted%20image%2020231020124052.png)
For each step of the animation, we analyse each voxel's current properties (such as current fluid capacity, inflow direction and speed, etc.) and simulate the effects on each other voxel to create a simulated fluid. A common technique for solving this kind of fluid simulation is **Eulerian Fluid Simulation**.

The final kind of fluid simulation is Hybrid Fluid Simulation, where there is both a voxel grid and a particle system, which are both used for certain aspects of the simulation.
![](Pasted%20image%2020231020124625.png)

# Collisions
When performing simulations of any kind, we need to know if two objects have intersected, and if so how they should respond. These problems are **collision detection** and **collision response**, respectively.
![](Pasted%20image%2020231020131908.png)
## Collision Detection
There are many different algorithms for detecting a collision between two objects, and the main factor that informs your choice is the geometry of the colliding object. For example, here is a collision between two rigid bodies, where the orange rectangle is an implicit surface (i.e. mathematically defined):
![](Pasted%20image%2020231020132039.png)
We know that when the function representing this surface equals zero that a coordinate is on the surface, and when the function is less than zero a coordinate is inside the surface. Therefore, it is trivial to know if a collision has occurred.
This is not so simple with all definitions of a surface, specifically with meshes. There is no guarantee that a mesh is even closed, so how could you know if you are "inside" it?
## Collision Response
Collision response has to do with the result of the collision; that is, how the objects involve move as a result of colliding.
Usually when we detect a collision we are already "too late" - in the last simulation step the colliding object was outside the collider, and in this step it is inside it.
![](Pasted%20image%2020231020132409.png)
One solution is to retroactively adjust our colliding object's position such that it is in the place where it should be. This is called backtracking:
![](Pasted%20image%2020231020132519.png)
We can do this by computing the intersection point between the colliding object's movement path and the collider, which gives us the exact point of collision.
With this point of collision, we can calculate the new direction, speed, etc. of the colliding object and advance it in that direction for the fractional time steps that we undid.
Alternatively, we can do a quick and dirty hack called "Fixing", where we simply take the final position of the colliding object and roughly adjust it to be on the surface of the collider:
![](Pasted%20image%2020231020132754.png)
We then apply the response from this point. This is inaccurate, but it may be simpler to compute in some situations.

## Complexity
The complexity of (na√Øve) collision detection is high; for $n$ dynamic objects, we must compare each object to every other and check for collisions, meaning collision detection runs in $O(n^2)$ time.
There are ways to improve the running time of collision detection, such as:
- Use simple, conservative proxies to reduce the impact of non-colliding checks
	- And use recursive/hierarchical tests to make these proxies more "precise", weeding out even more non-colliding checks
- Only compare objects that are both in the same close part of the scene

### Bounding Volumes
A common approach to improving the efficiency of collision detection is to collide with the bounding volumes of an object before the actual object's geometry.
![](Pasted%20image%2020231020133753.png)
Bounding volumes are generally very simple and easy to calculate intersections for. If the bounding volumes of two objects intersect, then they may or may not have actually intersected and a second check with the actual meshes is required.
There are various types of bounding boxes:
![](Pasted%20image%2020231020134843.png)
(AABB = Axis Aligned Bounding Box, OBB = Oriented Bounding Box, k-DOP = k-Discrete Oriented Polytopes)

We will cover sphere bounding boxes.
![](Pasted%20image%2020231020135328.png)
A bounding sphere is a sphere that is placed around an object such that the entire object fits exactly in the sphere. If the bounding spheres of two objects do not intersect, then the objects definitely don't intersect and we can skip the check. Vitally, checking if spheres are intersecting is very easy.
We can extend this to a hierarchical model, by performing a series of increasingly precise bounding sphere checks:
![](Pasted%20image%2020231020135753.png)
So first we check the bounding sphere, then we increase the number and decrease the size of the bounding spheres repeatedly in a series of more precise (but more time consuming) collision checks. Finally, if an object passes all of these tests then the actual collision of the meshes will be tested.