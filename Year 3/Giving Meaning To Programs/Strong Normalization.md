# Logical Predicates
We want to prove that our type system works well with beta-reduction, in order to show that those terms which were problematic in the untyped lambda calculus are no longer a problem in the typed lambda calculus. By showing that this language has stronger properties, we hope to make it easier to reason about.
To this end, we define a theoretical device known as a **logical predicate**. Informally, a logical predicate is a way of defining some property across all types in a uniform way. These properties which vary uniformly over types are precisely the ones which the type system gives us a reasoning principle for.
## Uniformity across types
In this case we model the properties we are interested in by defining the set of things which have the property. For now, think of a logical predicate as a set of terms, though we will need to add to this idea to make it really work.
Because we've decided to show how a property varies using the type of the terms involved, it makes sense to define not just a single set of "terms which satisfy the property", but instead to make many sets for each type $\tau$, containing only terms of that type. This makes it easier to state what we mean by "varying uniformly" with the type.
The general idea is that whenever our language gives a way for two terms to interact, there should be a well behaved property that the interaction preserves. In the simply typed lambda calculus the only interaction we have is for one term to be applied to the other. Therefore we need a way of saying that, if two terms hold some property and one is applied to the other, then the resulting term also holds this property.