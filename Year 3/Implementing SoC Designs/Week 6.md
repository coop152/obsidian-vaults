# Interconnects
You can broadly divide the topic of interconnecting blocks into two categories:
- Logical interfacing
	- Standard interfaces (AMBA, OCP, etc.)
	- The operation of the interface
- Electrical interfacing
	- Skew (Clock skew, bit skew for buses)
	- Round trip delays
	- Drive capacity

The latter set of topics is mostly saved for later weeks.
# Block Interconnection
In any sizeable SoC you are very likely to use IP (Intellectual Property) blocks to save time and effort.
When using IP blocks, standard interfaces are important. These cores are **black boxes**, so you have no control over how the core presents its interface - you need a way to fit it into your design in a consistent way, and standard interfaces are the means to this end.

## AMBA (Advanced Microcontroller Bus Architecture)
AMBA is an open standard (or a set of standards) which are by far the most popular standard on-chip interconnect. The standards specify what signals are used in the interconnection and their timing relationship on a cycle-by-cycle basis.
AMBA comes in several variations:
- APB (Advanced Peripheral Bus), which is simple but slow, and is intended for communications between rarely interacting peripheral devices.
- AHB (Advanced High-performance Bus), which is similar to APB but higher performance.
- AXI (Advanced eXtensible Interface), which is faster still.

APB and AHB are useful for slow shared buses, which connect multiple devices together. For example, you might use them to connect a RTC, a timer and GPIO pins to a microcontroller. They are unsuitable for low latency applications such as a data bus to memory.
AXI is suitable for low latency and high bandwidth applications such as connecting a microcontroller to some memory. In addition to being generally faster, it supports burst transfer and a pipeline that can hold several *outstanding transactions* at once. The added complexity makes AXI unsuitable for applications that connect a large number of blocks, such as the peripheral bus described for APB/AHB.

## OCP (Open Core Protocol)
This is another standard that exists. No more detail needs to be known.
## Traditional bus interface
![](Pasted%20image%2020231108102421.png)
The traditional bus design is asynchronous, with the timing of operations decided by strobes from the master block. The timing is generated by a clocked circuit, so it will coincide with the clock, but the bus itself does not transmit the clock. Everything happens successively; there may be wait states if a transfer can take longer than a cycle.

If the master block wanted to read, for example:
1. Takes Chip Select ($\overline{CS}$) low
2. At the same time, puts an address on the address bus
3. When the address is stable on the address bus, take Read ($\overline{\text{Read}}$) low.
4. Wait until the other block sends it's response. If the response time is always the same this may be as simple as waiting for some number of cycles, but if it is variable there will need to be a wait state for the other block to indicate to the master block when it's done.
5. When the other block is done, it puts the desired data on the read data bus.
6. The master block receives this data and takes chip select high. The state of the read data bus is now undefined.

The write operation is very similar.

This simple bus architecture is used in the lab for the interface between the drawing unit and the framestore.

There are variations on this protocol. For example:
![](Pasted%20image%2020231108104055.png)
This variation uses a R/W line to indicate the direction of the transfer instead of two read and write lines, and also introduces an enable line. This is functionally equivalent to the other design.

These two protocols transfer data **unidirectionally**, which is typical of *on-chip* buses. In contrast, *off-chip* buses typically use **bidirectional** data signals: this is to reduce the number of pins required on the package, as well as the amount of wiring on the PCB.
On-chip buses are not significantly restricted in width due to the considerable wiring resource on a chip - this makes using two buses acceptable. More importantly, using unidirectional buses allows electrical buffers (signal amplifiers, unrelated to data buffers!) to be inserted along the wires, which keeps switching edge speed high.

## APB (Advanced Peripheral Bus)
APB is extremely similar to a traditional bus. The bus master puts out a command, an address and (depending on the command) some write data. The bus master may also latch the read data at the end of the cycle.
![](Pasted%20image%2020231108105247.png)
This design, like the traditional bus, is simple to implement. It is optimised for minimal power consumption at the expense of low speed - it is ideal for low speed peripherals. APB only supports a single master.

The procedure to perform a read is quite simple:
1. Take Select high (to activate the bus)
2. At the same time, take Write low (to indicate a read)
3. At the same time, put an address on the address bus
4. When ready, take Enable high (to execute the operation)
5. Read the result from Read data, take enable low
6. Take select low if finished, or leave it high if more operations are to come

APB looks like this on the block level:
![](Pasted%20image%2020231108105859.png)
The first APB spec performed every transfer unconditionally in two clock cycles, as seen in the previous diagram. Subsequent specs extended this to add a wait state, so that slow peripherals can extend the cycle time if they cannot respond quickly enough. Because communications with peripheral devices are infrequent, the penalty is small and waiting is acceptable.

Another extension was to add an error signal, so that a peripheral can indicate the failure of a cycle to the bus master.
What kinds of errors can arise on a bus? We know of some memory operations errors:
- Segmentation faults: the address given is illegal.
	- May be outside the allowed range.
	- May be writing to a read only area.
	- May be writing to a privileged area.
- Page fault: the address given is legal, but it doesn't map to any physical memory at this time.

These errors are generally detected by a Memory Management Unit (MMU) before they reach the bus, but there are some that cannot be trapped there and *will* cause bus cycles.
For example, consider an I/O device that has 16 internal registers, but is mapped into the master's memory as an entire 1KB page. If the master attempts to access outside of the first 16 addresses in the "page", then the device must indicate that an invalid operation has occurred. The MMU **could not** catch this error early; it is only concerned with entire pages and not individual addresses.

## AHB (Advanced High-performance Bus)
AHB is a pipelined bus, which can perform one transfer per clock cycle.
![](Pasted%20image%2020231108111424.png)
AHB is moderately complex. Not shown on the diagram is the centralised arbitration system, which allows multiple masters to use the bus. Like APB, bus cycles can be extended or aborted. AHB is high performance enough to be used as a processor bus on medium performance devices (e.g. ARM9).

Because AHB is pipelined, the procedure for using it is more complicated. In one clock cycle, the master must:
1. Latch any incoming data on the read bus
2. Provide data on the write bus, if the previous clock was a write command
3. Send the next command, if it has another command to send

The peripheral must:
1. Latch the address from the last cycle's command
2. Begin whatever work it has been told to do (if writing, read the write data bus)
3. Put the result on the read data bus

This arrangement allows high bus throughput, but it causes difficulties when things don't go smoothly:
- If a peripheral is slow and needs to insert wait states, it does this in the "data phase". In other words, it informs the master (and other peripherals) that it needs more time the cycle it was expected to give a result; in this case, the master needs to hold the *next* command for longer, and the peripheral that performs that next command (if it is not the current one) needs to wait too.
![](Pasted%20image%2020231108113154.png)
- If a cycle results in an abort, the pipeline needs to be flushed. In this case, all peripherals must watch carefully for other devices aborting so that they don't start working on the subsequent cycle (which may already have been requested).
![](Pasted%20image%2020231108113301.png)

## AXI (Advanced eXtensible Interface)
AXI works more like a network than a bus. It revolves around **transactions** as opposed to bus cycles.
![](Pasted%20image%2020231108113639.png)
Information is sent over (semi-)independent channels, each of which is unidirectional and may also be pipelined.  The latency for each command may be many cycles, but the support for **burst transmission** can significantly improve the throughput.
Transactions may be completed out-of-order to maximise performance.

The transaction for a write operation comprises a write command of the address and the burst size, followed by a burst of write data, and concluding with a status response.
A read transaction is similar, but the data burst and status response are returned together.
Each channel has a transaction ID, which allows elements from multiple outstanding transactions to be matched appropriately.
